<!DOCTYPE html>
<html>
<head>
  <title>Constrained Ordination &amp; Permutation Tests</title>

  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="generator" content="pandoc" />




  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <base target="_blank">

  <script type="text/javascript">
    var SLIDE_CONFIG = {
      // Slide settings
      settings: {
                title: 'Constrained Ordination &amp; Permutation Tests',
                        useBuilds: true,
        usePrettify: true,
        enableSlideAreas: true,
        enableTouch: true,
                      },

      // Author information
      presenters: [
            {
        name:  'Naupaka Zimmerman and Gavin Simpson' ,
        company: '',
        gplus: '',
        twitter: '',
        www: '',
        github: ''
      },
            ]
    };
  </script>

  <link href="constrained-ordination_files/ioslides-13.5.1/fonts/fonts.css" rel="stylesheet" />
  <link href="constrained-ordination_files/ioslides-13.5.1/theme/css/default.css" rel="stylesheet" />
  <link href="constrained-ordination_files/ioslides-13.5.1/theme/css/phone.css" rel="stylesheet" />
  <script src="constrained-ordination_files/ioslides-13.5.1/js/modernizr.custom.45394.js"></script>
  <script src="constrained-ordination_files/ioslides-13.5.1/js/prettify/prettify.js"></script>
  <script src="constrained-ordination_files/ioslides-13.5.1/js/prettify/lang-r.js"></script>
  <script src="constrained-ordination_files/ioslides-13.5.1/js/prettify/lang-yaml.js"></script>
  <script src="constrained-ordination_files/ioslides-13.5.1/js/hammer.js"></script>
  <script src="constrained-ordination_files/ioslides-13.5.1/js/slide-controller.js"></script>
  <script src="constrained-ordination_files/ioslides-13.5.1/js/slide-deck.js"></script>

  <style type="text/css">

    b, strong {
      font-weight: bold;
    }

    em {
      font-style: italic;
    }

    slides > slide {
      -webkit-transition: all 0.4s ease-in-out;
      -moz-transition: all 0.4s ease-in-out;
      -o-transition: all 0.4s ease-in-out;
      transition: all 0.4s ease-in-out;
    }

    .auto-fadein {
      -webkit-transition: opacity 0.6s ease-in;
      -webkit-transition-delay: 0.4s;
      -moz-transition: opacity 0.6s ease-in 0.4s;
      -o-transition: opacity 0.6s ease-in 0.4s;
      transition: opacity 0.6s ease-in 0.4s;
      opacity: 0;
    }

  </style>


</head>

<body style="opacity: 0">

<slides class="layout-widescreen">

  <slide class="title-slide segue nobackground">
        <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
            <p style="margin-top: 6px; margin-left: -2px;">August 6, 2017 • ESA 2017</p>
          </hgroup>
  </slide>

<slide class='segue dark nobackground level1'><hgroup class = 'auto-fadein'><h2>Constrained Ordination</h2></hgroup><article  id="constrained-ordination" class="smaller ">

</article></slide><slide class=''><hgroup><h2>Canonical Correspondence Analysis</h2></hgroup><article  id="canonical-correspondence-analysis" class="smaller ">

<p>CCA is the constrained form of CA; fitted using <code>cca()</code>.</p>

<p>Two interfaces for specifying models</p>

<ul>
<li>basic; <code>cca1 &lt;- cca(X = varespec, Y = varechem)</code></li>
<li>formula; <code>cca1 &lt;- cca(varespec ~ ., data = varechem)</code></li>
</ul>

<p>Formula interface is the more powerful &#8212; <em>recommended</em></p>

</article></slide><slide class=''><hgroup><h2>Canonical Correspondence Analysis</h2></hgroup><article  id="canonical-correspondence-analysis-1" class="smaller ">

<pre class = 'prettyprint lang-r'>cca1 &lt;- cca(varespec ~ ., data = varechem)
cca1</pre>

<pre >Call: cca(formula = varespec ~ N + P + K + Ca + Mg + S + Al + Fe +
Mn + Zn + Mo + Baresoil + Humdepth + pH, data = varechem)

              Inertia Proportion Rank
Total          2.0832     1.0000     
Constrained    1.4415     0.6920   14
Unconstrained  0.6417     0.3080    9
Inertia is mean squared contingency coefficient 

Eigenvalues for constrained axes:
  CCA1   CCA2   CCA3   CCA4   CCA5   CCA6   CCA7   CCA8   CCA9  CCA10 
0.4389 0.2918 0.1628 0.1421 0.1180 0.0890 0.0703 0.0584 0.0311 0.0133 
 CCA11  CCA12  CCA13  CCA14 
0.0084 0.0065 0.0062 0.0047 

Eigenvalues for unconstrained axes:
    CA1     CA2     CA3     CA4     CA5     CA6     CA7     CA8     CA9 
0.19776 0.14193 0.10117 0.07079 0.05330 0.03330 0.01887 0.01510 0.00949 </pre>

</article></slide><slide class=''><hgroup><h2>Redundancy Analysis</h2></hgroup><article  id="redundancy-analysis" class="smaller ">

<p>RDA is the constrained form of PCA; fitted using <code>rda()</code>.</p>

<pre class = 'prettyprint lang-r'>rda1 &lt;- rda(varespec ~ ., data = varechem)
rda1</pre>

<pre >Call: rda(formula = varespec ~ N + P + K + Ca + Mg + S + Al + Fe +
Mn + Zn + Mo + Baresoil + Humdepth + pH, data = varechem)

                Inertia Proportion Rank
Total         1825.7000     1.0000     
Constrained   1459.9000     0.7997   14
Unconstrained  365.8000     0.2003    9
Inertia is variance 

Eigenvalues for constrained axes:
 RDA1  RDA2  RDA3  RDA4  RDA5  RDA6  RDA7  RDA8  RDA9 RDA10 RDA11 RDA12 
820.1 399.3 102.6  47.6  26.8  24.0  19.1  10.2   4.4   2.3   1.5   0.9 
RDA13 RDA14 
  0.7   0.3 

Eigenvalues for unconstrained axes:
   PC1    PC2    PC3    PC4    PC5    PC6    PC7    PC8    PC9 
186.19  88.46  38.19  18.40  12.84  10.55   5.52   4.52   1.09 </pre>

</article></slide><slide class=''><hgroup><h2>The <code>cca.object</code></h2></hgroup><article  id="the-cca.object" class="smaller ">

<ul>
<li>Objects of class <code>&quot;cca&quot;</code> are complex with many components</li>
<li>Entire class described in <code>?cca.object</code></li>
<li>Depending on what analysis performed some components may be <code>NULL</code></li>
<li>Used for (C)CA, PCA, RDA, and CAP (<code>capscale()</code>)</li>
</ul>

</article></slide><slide class=''><hgroup><h2>The <code>cca.object</code></h2></hgroup><article  id="the-cca.object-1" class="smaller ">

<p><code>cca1</code> has a large number of components</p>

<ul>
<li><strong><code>$call</code></strong> how the function was called</li>
<li><strong><code>$grand.total</code></strong> in (C)CA sum of `rowsum}</li>
<li><strong><code>$rowsum</code></strong> the row sums</li>
<li><strong><code>$colsum</code></strong> the column sums</li>
<li><strong><code>$tot.chi</code></strong> total inertia, sum of Eigenvalues</li>
<li><strong><code>$pCCA</code></strong> Conditioned (partialled out) components</li>
<li><strong><code>$CCA</code></strong> Constrained components</li>
<li><strong><code>$CA</code></strong> Unconstrained components</li>
<li><strong><code>$method</code></strong> Ordination method used</li>
<li><strong><code>$inertia</code></strong> Description of what inertia is</li>
</ul>

</article></slide><slide class=''><hgroup><h2>The <code>cca.object</code></h2></hgroup><article  id="the-cca.object-2" class="smaller ">

<p>Depending on how one called <code>cca()</code> etc some of these components will be <code>NULL</code></p>

<p><code>$pCCA</code> is only filled in if a <em>partial</em> constrained ordination fitted</p>

<p><code>rda()</code> returns objects with classes <code>&quot;rda&quot;</code> and <code>&quot;cca&quot;</code>, but in most cases those objects work like those of class <code>&quot;cca&quot;</code></p>

<p>The Eigenvalues and axis scores are now spread about the <code>$CA</code> and <code>$CCA</code> components (also <code>$pCCA</code> if a <em>partial</em> CCA)</p>

<p>Thankfully we can use <em>extractor</em> functions to get at such things</p>

</article></slide><slide class=''><hgroup><h2>Eigenvalues</h2></hgroup><article  id="eigenvalues" class="smaller ">

<p>Use <code>eigenvals()</code> to extract Eigenvalues from a fitted ordination object</p>

<pre class = 'prettyprint lang-r'>eigenvals(cca1)</pre>

<pre >     CCA1      CCA2      CCA3      CCA4      CCA5      CCA6      CCA7 
0.4388704 0.2917753 0.1628465 0.1421302 0.1179519 0.0890291 0.0702945 
     CCA8      CCA9     CCA10     CCA11     CCA12     CCA13     CCA14 
0.0583592 0.0311408 0.0132944 0.0083644 0.0065385 0.0061563 0.0047332 
      CA1       CA2       CA3       CA4       CA5       CA6       CA7 
0.1977645 0.1419256 0.1011741 0.0707868 0.0533034 0.0332994 0.0188676 
      CA8       CA9 
0.0151044 0.0094876 </pre>

</article></slide><slide class=''><hgroup><h2>Extracting axis scores</h2></hgroup><article  id="extracting-axis-scores" class="smaller ">

<p>To extract a range of scores from a fitted ordination use <code>scores()</code></p>

<ul>
<li>takes an ordination object as the first argument</li>
<li><code>choices</code> &#8212; which axes? Defaults to <code>c(1,2)</code></li>
<li><code>display</code> &#8212; which type(s) of scores to return

<ul>
<li><code>&quot;sites&quot;</code> or <code>&quot;wa&quot;</code>: scores for samples in response matrix</li>
<li><code>&quot;species&quot;</code>: scores for variables/columns in response</li>
<li><code>&quot;lc&quot;</code>: linear combination site scores</li>
<li><code>&quot;bp&quot;</code>: biplot scores (coords of arrow tip)</li>
<li><code>&quot;cn&quot;</code>: centroid scores (coords of factor centroids)</li>
</ul></li>
</ul>

</article></slide><slide class=''><hgroup><h2>Extracting axis scores</h2></hgroup><article  id="extracting-axis-scores-1" class="smaller ">

<pre class = 'prettyprint lang-r'>str(scores(cca1, choices = 1:4, display = c(&quot;species&quot;,&quot;sites&quot;)), max = 1)</pre>

<pre >List of 2
 $ species: num [1:44, 1:4] 0.0753 -0.1813 -1.0535 -1.2774 -0.1526 ...
  ..- attr(*, &quot;dimnames&quot;)=List of 2
 $ sites  : num [1:24, 1:4] 0.178 -0.97 -1.28 -1.501 -0.598 ...
  ..- attr(*, &quot;dimnames&quot;)=List of 2</pre>

<pre class = 'prettyprint lang-r'>head(scores(cca1, choices = 1:2, display = &quot;sites&quot;))</pre>

<pre >         CCA1       CCA2
18  0.1784733 -1.0598842
15 -0.9702382 -0.1971387
24 -1.2798478  0.4764498
27 -1.5009195  0.6521559
23 -0.5980933 -0.1840362
19 -0.1102881  0.7143142</pre>

</article></slide><slide class=''><hgroup><h2>Scalings&#8230;</h2></hgroup><article  id="scalings..." class="smaller ">

<p>When we draw the results of many ordinations we display 2 or more sets of data</p>

<p>Can&#39;t display all of these and maintain relationships between the scores</p>

<p><em>Solution</em> scale one set of scores relative to the other</p>

<p>Controlled via the <code>scaling</code> argument</p>

<ul>
<li><code>scaling = 1</code> &#8212; Focus on sites, scale site scores by \(\lambda_i\)</li>
<li><code>scaling = 2</code> &#8212; Focus on species, scale species scores by \(\lambda_i\)</li>
<li><code>scaling = 3</code> &#8212; Symmetric scaling, scale both scores by \(\sqrt{\lambda_i}\)</li>
<li><code>scaling = -1</code> &#8212; As above, but</li>
<li><code>scaling = -2</code> &#8212; For <code>cca()</code> multiply results by \(\sqrt{(1/(1-\lambda_i))}\)</li>
<li><code>scaling = -3</code> &#8212; this is Hill&#39;s scaling</li>
<li><code>scaling &lt; 0</code> &#8212; For <code>rda()</code> divide species scores by species&#39; \(\sigma\)</li>
<li><code>scaling = 0</code> &#8212; raw scores</li>
</ul>

<pre class = 'prettyprint lang-r'>scores(cca1, choices = 1:2, display = &quot;species&quot;, scaling = 3)</pre>

</article></slide><slide class=''><hgroup><h2>Partial constrained ordinations</h2></hgroup><article  id="partial-constrained-ordinations" class="smaller ">

<p><em>Partial</em> constrained ordinations remove the effect of one or more variables <em>then</em> fit model of interest</p>

<p>Argument <code>Z</code> is used for a data frame of variables to partial out</p>

<p>Or with the formula interface use the <code>Condition()</code> function</p>

<pre class = 'prettyprint lang-r'>pcca &lt;- cca(X = varespec,
            Y = varechem[, &quot;Ca&quot;, drop = FALSE],
            Z = varechem[, &quot;pH&quot;, drop = FALSE])
pcca &lt;- cca(varespec ~ Ca + Condition(pH), data = varechem) ## easier!</pre>

</article></slide><slide class='segue dark nobackground level1'><hgroup class = 'auto-fadein'><h2>Plotting constrained ordinations</h2></hgroup><article  id="plotting-constrained-ordinations" class="smaller ">

</article></slide><slide class=''><hgroup><h2>Triplots</h2></hgroup><article  id="triplots" class="smaller ">

<p>Triplots will generally produce a mess; we can really only display a couple of bits approximately anyway</p>

<p>Trying to cram three things in is a recipe for a mess&#8230;</p>

<p>&#8230;but we can do it</p>

<pre class = 'prettyprint lang-r'>plot(cca1)</pre>

</article></slide><slide class=''><hgroup><h2>Triplots</h2></hgroup><article  id="triplots-1" class="smaller ">

<pre class = 'prettyprint lang-r'>plot(cca1)</pre>

<img src='constrained-ordination_files/figure-html/triplot-2-1.png' title='fig:'/>

</article></slide><slide class='segue dark nobackground level1'><hgroup class = 'auto-fadein'><h2>Model building</h2></hgroup><article  id="model-building" class="smaller ">

</article></slide><slide class=''><hgroup><h2>Building constrained ordination models</h2></hgroup><article  id="building-constrained-ordination-models" class="smaller ">

<p>If we don&#39;t want to think it&#39;s easy to fit a poor model with many constraints</p>

<p>That&#39;s what we just did with <code>cca1</code> and <code>rda1</code></p>

<p>Remember, CCA and RDA are <em>just regression methods</em> &#8212; everything you know about regression applies here</p>

<p>A better approach is to <em>think</em> about the important variables and include only those</p>

<p>The formula interface allows you to create interaction or quadratic terms easily (though be careful with latter)</p>

<p>It also handles factor or class constraints automatically unlike the basic interface</p>

</article></slide><slide class=''><hgroup><h2>Building constrained ordination models</h2></hgroup><article  id="building-constrained-ordination-models-1" class="smaller ">

<pre class = 'prettyprint lang-r'>vare.cca &lt;- cca(varespec ~ Al + P*(K + Baresoil), data = varechem)
vare.cca</pre>

<pre >Call: cca(formula = varespec ~ Al + P * (K + Baresoil), data =
varechem)

              Inertia Proportion Rank
Total           2.083      1.000     
Constrained     1.046      0.502    6
Unconstrained   1.038      0.498   17
Inertia is mean squared contingency coefficient 

Eigenvalues for constrained axes:
  CCA1   CCA2   CCA3   CCA4   CCA5   CCA6 
0.3756 0.2342 0.1407 0.1323 0.1068 0.0561 

Eigenvalues for unconstrained axes:
    CA1     CA2     CA3     CA4     CA5     CA6     CA7     CA8 
0.27577 0.15411 0.13536 0.11803 0.08887 0.05511 0.04919 0.03781 
(Showed only 8 of all 17 unconstrained eigenvalues)</pre>

</article></slide><slide class=''><hgroup><h2>Building constrained ordination models</h2></hgroup><article  id="building-constrained-ordination-models-2" class="smaller ">

<p>For CCA we have little choice but to do</p>

<ol>
<li>Fit well-chosen set of candidate models &amp; compare, or</li>
<li>Fit a <em>full</em> model of well-chosen variables &amp; then do stepwise selection</li>
</ol>

<p>But automatic approaches to model building should be used cautiously!</p>

<p>The standard <code>step()</code> function can be used as <strong>vegan</strong> provides two helper methods, <code>deviance()</code> and <code>extractAIC()</code>, used by <code>step()</code></p>

<p>Vegan also provides methods for class <code>&quot;cca&quot;</code> for <code>add1()</code> and <code>drop1()</code></p>

</article></slide><slide class=''><hgroup><h2>Variance inflation factors</h2></hgroup><article  id="variance-inflation-factors" class="smaller ">

<p><em>Linear</em> dependencies between constraints can be investigated via the <em>variance inflation factor</em> or VIF</p>

<p>VIF is a measure of how much the variance of \(\hat{\beta}_j\) is inflated by presence of other covariates</p>

<p>Lots of rules of thumb</p>

<ul>
<li>VIF &gt;= 20 indicates <em>strong collinearity</em> in constraints</li>
<li>VIF &gt;= 10 potentially of concern &amp; should be looked at</li>
</ul>

<p>Computed via <code>vif.cca()</code></p>

</article></slide><slide class=''><hgroup><h2>Stepwise selection in CCA</h2></hgroup><article  id="stepwise-selection-in-cca" class="smaller ">

<p><code>step()</code> uses AIC which is a fudge for RDA/CCA. Alternatively use function <code>ordistep()</code></p>

<ol>
<li>Define an upper and lower model scope, say the full model and the null model</li>
<li>To step from the lower scope or null model we use</li>
</ol>

<pre class = 'prettyprint lang-r'>upr &lt;- cca(varespec ~ ., data = varechem)
lwr &lt;- cca(varespec ~ 1, data = varechem)
set.seed(1)
mods &lt;- ordistep(lwr, scope = formula(upr), trace = 0)</pre>

<p><code>trace = 0</code> is used her to turn off printing of progress</p>

<p>Permutation tests are used (more on these later); the theory for an AIC for ordination is somewhat loose</p>

</article></slide><slide class=''><hgroup><h2>Stepwise selection in CCA</h2></hgroup><article  id="stepwise-selection-in-cca-1" class="smaller ">

<p>The object returned by <code>step()</code> is a standard <code>&quot;cca&quot;</code> object with an extra component <code>$anova</code></p>

<p>The <code>$anova</code> component contains a summary of the steps involved in automatic model building</p>

<pre class = 'prettyprint lang-r'>mods</pre>

<pre >Call: cca(formula = varespec ~ Al + P + K, data = varechem)

              Inertia Proportion Rank
Total          2.0832     1.0000     
Constrained    0.6441     0.3092    3
Unconstrained  1.4391     0.6908   20
Inertia is mean squared contingency coefficient 

Eigenvalues for constrained axes:
  CCA1   CCA2   CCA3 
0.3616 0.1700 0.1126 

Eigenvalues for unconstrained axes:
   CA1    CA2    CA3    CA4    CA5    CA6    CA7    CA8 
0.3500 0.2201 0.1851 0.1551 0.1351 0.1003 0.0773 0.0537 
(Showed only 8 of all 20 unconstrained eigenvalues)</pre>

</article></slide><slide class=''><hgroup><h2>Stepwise selection in CCA</h2></hgroup><article  id="stepwise-selection-in-cca-2" class="smaller ">

<p>The <code>$anova</code> component contains a summary of the steps involved in automatic model building</p>

<pre class = 'prettyprint lang-r'>mods$anova</pre>

<pre >     Df    AIC      F Pr(&gt;F)   
+ Al  1 128.61 3.6749  0.005 **
+ P   1 127.91 2.5001  0.005 **
+ K   1 127.44 2.1688  0.035 * 
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

</article></slide><slide class=''><hgroup><h2>Stepwise selection in CCA</h2></hgroup><article  id="stepwise-selection-in-cca-3" class="smaller ">

<p>Step-wise model selection is fairly fragile; if we start from the full model we won&#39;t end up with the same final model</p>

<pre class = 'prettyprint lang-r'>mods2 &lt;- step(upr, scope = list(lower = formula(lwr), upper = formula(upr)), trace = 0,
              test = &quot;perm&quot;)
mods2</pre>

<pre >Call: cca(formula = varespec ~ P + K + Mg + S + Mn + Mo + Baresoil
+ Humdepth, data = varechem)

              Inertia Proportion Rank
Total          2.0832     1.0000     
Constrained    1.1165     0.5360    8
Unconstrained  0.9667     0.4640   15
Inertia is mean squared contingency coefficient 

Eigenvalues for constrained axes:
  CCA1   CCA2   CCA3   CCA4   CCA5   CCA6   CCA7   CCA8 
0.4007 0.2488 0.1488 0.1266 0.0875 0.0661 0.0250 0.0130 

Eigenvalues for unconstrained axes:
    CA1     CA2     CA3     CA4     CA5     CA6     CA7     CA8     CA9 
0.25821 0.18813 0.11927 0.10204 0.08791 0.06085 0.04461 0.02782 0.02691 
   CA10    CA11    CA12    CA13    CA14    CA15 
0.01646 0.01364 0.00823 0.00655 0.00365 0.00238 </pre>

</article></slide><slide class=''><hgroup><h2>Adjusted \(R^2\) for <em>linear</em> models</h2></hgroup><article  id="adjusted-r2-for-linear-models" class="smaller ">

<p>As with ordinary \(R^2\), that of an RDA is biased for the same reasons as for a linear regression</p>

<ul>
<li>adding a variable to constraints will increase \(R^2\)</li>
<li>the larger the number of constraints in the model the larger \(R^2\) is due to random correlations</li>
</ul>

<p>Can attempt to account for this bias via an <em>adjusted</em> \(R^2\) measure</p>

<p>\[R^2_{adj} = 1 - \frac{n - 1}{n - m - 1}(1 - R^2)\]</p>

<p>where</p>

<ul>
<li>\(n\) is number of samples</li>
<li><p>\(m\) is number of constraints (model degrees of freedom)</p></li>
<li>Can be used up to \(\sim M &gt; n/2\) before becomes too conservative</li>
<li>Can be negative</li>
<li><p>Compute using <code>RsquareAdj()</code></p></li>
</ul>

</article></slide><slide class=''><hgroup><h2>Stepwise selection via adjusted \(R^2\)</h2></hgroup><article  id="stepwise-selection-via-adjusted-r2" class="smaller ">

<p>The problems with stepwise selection in regression models are myriad. Affects RDA, CCA, etc as well</p>

<p><span class="cite">Blanchet, Legendre, and Borcard (2008)</span> proposed a two-step solution for models where \(R^2_{adj}\) makes sense</p>

<ul>
<li><em>Global test</em> of all constraints

<ul>
<li>Proceed <strong>only</strong> if this test is significant</li>
<li>Helps prevent inflation of overall type I error</li>
</ul></li>
<li>Proceed with forward selection, but with <em>two</em> stopping rules

<ul>
<li>Usual significance threshold \(\alpha\)</li>
<li>The global \(R^2_{adj}\)</li>
<li>Stop if next candidate model is non-significant or if \(R^2_{adj}\) exceeds the global \(R^2_{adj}\)</li>
</ul></li>
</ul>

<p>Available in <code>ordiR2step()</code></p>

</article></slide><slide class='segue dark nobackground level1'><hgroup class = 'auto-fadein'><h2>Permutation tests</h2></hgroup><article  id="permutation-tests" class="smaller ">

</article></slide><slide class=''><hgroup><h2>Permutation tests in vegan</h2></hgroup><article  id="permutation-tests-in-vegan" class="smaller ">

<p>RDA has lots of theory behind it, CCA not as much. However, ecological/environmental data invariably violate what little theory we have</p>

<p>Instead we use permutation tests to assess the <em>importance</em> of fitted models &#8212; the data are shuffled in some way and the model refitted to derive a Null distribution under some hypothesis of <em>no effect</em></p>

</article></slide><slide class=''><hgroup><h2>Permutation tests in vegan</h2></hgroup><article  id="permutation-tests-in-vegan-1" class="smaller ">

<p>What <em>is</em> shuffled and <em>how</em> is of <strong>paramount</strong> importance for the test to be valid</p>

<ul>
<li>No conditioning (partial) variables then rows of the species data are permuted</li>
<li>With conditioning variables, two options are available, both of which <em>permute residuals</em> from model fits

<ul>
<li>The <em>full model</em> uses residuals from model \(Y = X + Z + \varepsilon\)</li>
<li>The <em>reduced model</em> uses residuals from model \(Y = X + Z + \varepsilon\)</li>
</ul></li>
<li>In <strong>vegan</strong> which is used can be set via argument <code>method</code> with <code>&quot;direct&quot;</code>, <code>&quot;full&quot;</code>, and <code>&quot;reduced&quot;</code> respectively</li>
</ul>

</article></slide><slide class=''><hgroup><h2>Permutation tests in vegan</h2></hgroup><article  id="permutation-tests-in-vegan-2" class="smaller ">

<p>A test statistic is required, computed for observed model &amp; each permuted model</p>

<p><strong>vegan</strong> uses a pseudo-\(F\) statistic</p>

<p>\[F=\frac{\chi^2_{model} / df_{model}}{\chi^2_{resid} / df_{resid}}\]</p>

<p>Evaluate whether \(F\) is unusually large relative to the null (permutation) distribution of \(F\)</p>

</article></slide><slide class=''><hgroup><h2>Permutation tests in vegan: <code>anova()</code></h2></hgroup><article  id="permutation-tests-in-vegan-anova" class="smaller ">

<ul>
<li>The main user function is the <code>anova()</code> method</li>
<li>It is an interface to the lower-level function <code>permutest.cca()</code></li>
<li>At its most simplest, the  method tests whether the ``model&#39;&#39; as a whole is significant \[F = \frac{1.4415 / 14}{0.6417 / 9} = 1.4441\]</li>
</ul>

<pre class = 'prettyprint lang-r'>set.seed(42)
(perm &lt;- anova(cca1))</pre>

<pre >Permutation test for cca under reduced model
Permutation: free
Number of permutations: 999

Model: cca(formula = varespec ~ N + P + K + Ca + Mg + S + Al + Fe + Mn + Zn + Mo + Baresoil + Humdepth + pH, data = varechem)
         Df ChiSquare      F Pr(&gt;F)  
Model    14   1.44148 1.4441  0.041 *
Residual  9   0.64171                
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

</article></slide><slide class=''><hgroup><h2>Permutation tests in vegan: <code>anova()</code></h2></hgroup><article  id="permutation-tests-in-vegan-anova-1" class="smaller ">

<ul>
<li><code>anova()</code> will continue permuting only as long as it is uncertain whether the the \(p\)-value is above or below the chosen threshold (say \(p = 0.05\))</li>
<li>If the function is sure the permuted \(p\) is above the threshold <code>anova()</code> may return after only a few hundred permutations</li>
<li>In other cases many hundreds or thousands of permutations may be required to say whether the model is above or below the threshold</li>
<li>In the example, 1599 permutations were required</li>
</ul>

<pre class = 'prettyprint lang-r'>perm</pre>

<pre >Permutation test for cca under reduced model
Permutation: free
Number of permutations: 999

Model: cca(formula = varespec ~ N + P + K + Ca + Mg + S + Al + Fe + Mn + Zn + Mo + Baresoil + Humdepth + pH, data = varechem)
         Df ChiSquare      F Pr(&gt;F)  
Model    14   1.44148 1.4441  0.041 *
Residual  9   0.64171                
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

</article></slide><slide class=''><hgroup><h2>Permutation tests in vegan: <code>anova()</code></h2></hgroup><article  id="permutation-tests-in-vegan-anova-2" class="smaller ">

<ul>
<li><code>anova.cca()</code> has a number of arguments</li>
</ul>

<pre class = 'prettyprint lang-r'>args(anova.cca)</pre>

<pre >function (object, ..., permutations = how(nperm = 999), by = NULL, 
    model = c(&quot;reduced&quot;, &quot;direct&quot;, &quot;full&quot;), parallel = getOption(&quot;mc.cores&quot;), 
    strata = NULL, cutoff = 1, scope = NULL) 
NULL</pre>

<ul>
<li><code>alpha</code> is the desired \(p\) value threshold (Type I error rate)</li>
<li><code>beta</code> is the Type II error rate</li>
<li>Permuting stops if the result is different from <code>alpha</code> for the given <code>beta</code></li>
<li>This is evaluated every <code>step</code> permutations</li>
<li><code>perm.max</code> sets a limit on the number of permutations</li>
<li><code>by</code> determines what is tested; the default is to test the model</li>
<li>More direct control can be achieved via <code>permutest.cca()</code></li>
</ul>

</article></slide><slide class=''><hgroup><h2>Types of permutation test in vegan</h2></hgroup><article  id="types-of-permutation-test-in-vegan" class="smaller ">

<p>A number of types of test can be envisaged</p>

<ul>
<li>Testing the overall significance of the model</li>
<li>Testing constrained (canonical) axes</li>
<li>Testing individual model terms <em>sequentially</em></li>
<li>The <em>marginal</em> effect of a single variable</li>
</ul>

<p>The first is the default in <code>anova()</code></p>

<p>The other three can be selected via the argument <code>method</code></p>

</article></slide><slide class=''><hgroup><h2>Permutation tests </h2><h3> testing canonical axes</h3></hgroup><article  id="permutation-tests-testing-canonical-axes" class="smaller ">

<ul>
<li>The constrained (canonical) axes can be individually tests by specifying <code>by = &quot;axis&quot;</code></li>
<li>The first axis is tested in terms of variance explained compared to residual variance</li>
<li>The second axis is tested after partialling out the first axis&#8230; and so on</li>
</ul>

<pre class = 'prettyprint lang-r'>set.seed(1)
anova(mods, by = &quot;axis&quot;)</pre>

<pre >Permutation test for cca under reduced model
Marginal tests for axes
Permutation: free
Number of permutations: 999

Model: cca(formula = varespec ~ Al + P + K, data = varechem)
         Df ChiSquare      F Pr(&gt;F)    
CCA1      1   0.36156 5.0249  0.001 ***
CCA2      1   0.16996 2.3621  0.011 *  
CCA3      1   0.11262 1.5651  0.124    
Residual 20   1.43906                  
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

</article></slide><slide class=''><hgroup><h2>Permutation tests </h2><h3> testing terms sequentially</h3></hgroup><article  id="permutation-tests-testing-terms-sequentially" class="smaller ">

<ul>
<li>The individual terms in the model can be tested using <code>by = &quot;terms&quot;</code></li>
<li>The terms are assessed in the order they were specified in the model, sequentially from first to last</li>
<li>Test is of the additional variance explained by adding the \(k\)th variable to the model</li>
<li><strong>Ordering of the terms</strong> will affect the results</li>
</ul>

<pre class = 'prettyprint lang-r'>set.seed(5)
anova(mods, by = &quot;terms&quot;)</pre>

<pre >Permutation test for cca under reduced model
Terms added sequentially (first to last)
Permutation: free
Number of permutations: 999

Model: cca(formula = varespec ~ Al + P + K, data = varechem)
         Df ChiSquare      F Pr(&gt;F)    
Al        1   0.29817 4.1440  0.001 ***
P         1   0.18991 2.6393  0.011 *  
K         1   0.15605 2.1688  0.024 *  
Residual 20   1.43906                  
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

</article></slide><slide class=''><hgroup><h2>Permutation tests </h2><h3> testing terms marginal effects</h3></hgroup><article  id="permutation-tests-testing-terms-marginal-effects" class="smaller ">

<ul>
<li>The marginal <em>effect</em> of a model term can be assessed using <code>by = &quot;margin&quot;</code></li>
<li>The marginal <em>effect</em> is the effect of a particular term when all other model terms are included in the model</li>
</ul>

<pre class = 'prettyprint lang-r'>set.seed(10)
anova(mods, by = &quot;margin&quot;)</pre>

<pre >Permutation test for cca under reduced model
Marginal effects of terms
Permutation: free
Number of permutations: 999

Model: cca(formula = varespec ~ Al + P + K, data = varechem)
         Df ChiSquare      F Pr(&gt;F)    
Al        1   0.31184 4.3340  0.001 ***
P         1   0.16810 2.3362  0.012 *  
K         1   0.15605 2.1688  0.025 *  
Residual 20   1.43906                  
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

</article></slide><slide class=''><hgroup><h2>Constrained ordination worked example </h2><h3> spring meadow vegetation</h3></hgroup><article  id="constrained-ordination-worked-example-spring-meadow-vegetation" class="smaller ">

<p>Example &amp; data taken from Leps &amp; Smilauer, Case Study 2</p>

<p>Spring fen meadow vegetation in westernmost Carpathian mountains</p>

<pre class = 'prettyprint lang-r'>## load vegan
library(&quot;vegan&quot;)

## load the data
spp &lt;- read.csv(&quot;data/meadow-spp.csv&quot;, header = TRUE, row.names = 1)
env &lt;- read.csv(&quot;data/meadow-env.csv&quot;, header = TRUE, row.names = 1)</pre>

</article></slide><slide class=''><hgroup><h2>Constrained ordination worked example </h2><h3> spring meadow vegetation</h3></hgroup><article  id="constrained-ordination-worked-example-spring-meadow-vegetation-1" class="smaller ">

<p>CCA a reasonable starting point as the gradient is long here (check with <code>decorana()</code> if you want)</p>

<pre class = 'prettyprint lang-r'>m1 &lt;- cca(spp ~ ., data = env)
set.seed(32)
anova(m1)</pre>

<pre >Permutation test for cca under reduced model
Permutation: free
Number of permutations: 999

Model: cca(formula = spp ~ Ca + Mg + Fe + K + Na + Si + SO4 + PO4 + NO3 + NH3 + Cl + Corg + pH + conduct + slope, data = env)
         Df ChiSquare     F Pr(&gt;F)    
Model    15    1.5597 1.497  0.001 ***
Residual 54    3.7509                 
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

</article></slide><slide class=''><hgroup><h2>Constrained ordination worked example </h2><h3> spring meadow vegetation</h3></hgroup><article  id="constrained-ordination-worked-example-spring-meadow-vegetation-2" class="smaller ">

<img src='constrained-ordination_files/figure-html/meadows-cca-full-triplot-1.png' title='fig:'/>

</article></slide><slide class=''><hgroup><h2>Constrained ordination worked example </h2><h3> spring meadow vegetation</h3></hgroup><article  id="constrained-ordination-worked-example-spring-meadow-vegetation-3" class="smaller ">

<pre class = 'prettyprint lang-r'>set.seed(67)
lwr &lt;- cca(spp ~ 1, data = env)
m2 &lt;- ordistep(lwr, scope = formula(m1), perm.max = 499, trace = FALSE)</pre>

<pre class = 'prettyprint lang-r'>m2</pre>

<pre >Call: cca(formula = spp ~ Ca + conduct + Corg + Na + NH3 + Fe +
pH, data = env)

              Inertia Proportion Rank
Total          5.3110     1.0000     
Constrained    0.9900     0.1864    7
Unconstrained  4.3210     0.8136   62
Inertia is mean squared contingency coefficient 

Eigenvalues for constrained axes:
  CCA1   CCA2   CCA3   CCA4   CCA5   CCA6   CCA7 
0.4268 0.1447 0.1116 0.0936 0.0760 0.0719 0.0652 

Eigenvalues for unconstrained axes:
    CA1     CA2     CA3     CA4     CA5     CA6     CA7     CA8 
0.27251 0.19518 0.16703 0.14993 0.14606 0.14168 0.13292 0.12154 
(Showed only 8 of all 62 unconstrained eigenvalues)</pre>

</article></slide><slide class=''><hgroup><h2>Constrained ordination worked example </h2><h3> spring meadow vegetation</h3></hgroup><article  id="constrained-ordination-worked-example-spring-meadow-vegetation-4" class="smaller ">

<img src='constrained-ordination_files/figure-html/meadows-cca-reduced-triplot-1.png' title='fig:'/>

</article></slide><slide class=''><hgroup><h2>Constrained ordination worked example </h2><h3> spring meadow vegetation</h3></hgroup><article  id="constrained-ordination-worked-example-spring-meadow-vegetation-5" class="smaller ">

<pre class = 'prettyprint lang-r'>m2$anova</pre>

<pre >          Df    AIC      F Pr(&gt;F)   
+ Ca       1 453.14 4.7893  0.005 **
+ conduct  1 453.29 1.7915  0.005 **
+ Corg     1 453.61 1.6011  0.005 **
+ Na       1 453.93 1.5827  0.005 **
+ NH3      1 454.36 1.4507  0.020 * 
+ Fe       1 454.89 1.3386  0.015 * 
+ pH       1 455.46 1.2756  0.015 * 
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

</article></slide><slide class=''><hgroup><h2>Constrained ordination worked example </h2><h3> spring meadow vegetation</h3></hgroup><article  id="constrained-ordination-worked-example-spring-meadow-vegetation-6" class="smaller ">

<p>Alternative is RDA with a transformation</p>

<pre class = 'prettyprint lang-r'>spph &lt;- decostand(spp, method = &quot;hellinger&quot;)
m3 &lt;- rda(spph ~ ., data = env)
lwr &lt;- rda(spph ~ 1, data = env)
m4 &lt;- ordistep(lwr, scope = formula(m3), perm.max = 199, trace = FALSE)</pre>

</article></slide><slide class=''><hgroup><h2>Constrained ordination worked example </h2><h3> spring meadow vegetation</h3></hgroup><article  id="constrained-ordination-worked-example-spring-meadow-vegetation-7" class="smaller ">

<img src='constrained-ordination_files/figure-html/meadows-rda-reduced-triplot-1.png' title='fig:'/>

</article></slide><slide class=''><hgroup><h2>Constrained ordination worked example </h2><h3> spring meadow vegetation</h3></hgroup><article  id="constrained-ordination-worked-example-spring-meadow-vegetation-8" class="smaller ">

<p>Stepwise using \(R^2_{adj}\)</p>

<pre class = 'prettyprint lang-r'>m5 &lt;- ordiR2step(lwr, scope = formula(m3), perm.max = 199, trace = FALSE)
m5$anova</pre>

<pre >                 R2.adj Df     AIC       F Pr(&gt;F)   
+ Ca            0.12588  1 -41.779 10.9370  0.002 **
+ NH3           0.14628  1 -42.468  2.6242  0.002 **
+ conduct       0.16322  1 -42.925  2.3570  0.002 **
+ Si            0.17711  1 -43.164  2.1136  0.002 **
+ Corg          0.18518  1 -42.940  1.6442  0.006 **
+ NO3           0.19257  1 -42.680  1.5853  0.018 * 
+ pH            0.19966  1 -42.417  1.5583  0.010 **
&lt;All variables&gt; 0.20332                             
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

</article></slide><slide class=''><hgroup><h2>Diagnostics for constrained ordinations</h2></hgroup><article  id="diagnostics-for-constrained-ordinations" class="smaller ">

<p><strong>vegan</strong> provides a series of diagnostics to help assess the model fit</p>

<ul>
<li><code>goodness()</code></li>
<li><code>inertcomp()</code></li>
<li><code>spenvcor()</code></li>
<li><code>intersetcor()</code></li>
<li><code>vif.caa()</code></li>
</ul>

</article></slide><slide class=''><hgroup><h2>Diagnostics for constrained ordinations </h2><h3> goodness of fit</h3></hgroup><article  id="diagnostics-for-constrained-ordinations-goodness-of-fit" class="smaller ">

<p><code>goodness()</code> computes two goodness of fit statistics for species or sites</p>

<p>Which goodness of fit measure is returned is controlled by argument <code>statistic</code></p>

<ul>
<li><code>statistic = &quot;explained</code> (default) gives the cumulative proportion of variance explained by each axis</li>
<li><code>statistic = &quot;distance&quot;</code> gives the residual distance between the &quot;fitted&quot; location in constrained ordination space and the location in the full dimensional space</li>
</ul>

</article></slide><slide class=''><hgroup><h2>Diagnostics for constrained ordinations </h2><h3> goodness of fit</h3></hgroup><article  id="diagnostics-for-constrained-ordinations-goodness-of-fit-1" class="smaller ">

<pre class = 'prettyprint lang-r'>head(goodness(mods))</pre>

<pre >                 CCA1        CCA2      CCA3
Callvulg 0.0062471656 0.318907619 0.8254657
Empenigr 0.1164701677 0.137604904 0.1953245
Rhodtome 0.0999089739 0.169697909 0.1824153
Vaccmyrt 0.2361482843 0.240516323 0.2406730
Vaccviti 0.1523704591 0.156502301 0.2110550
Pinusylv 0.0009244423 0.004802076 0.0060096</pre>

<pre class = 'prettyprint lang-r'>head(goodness(mods, summarize = TRUE))</pre>

<pre > Callvulg  Empenigr  Rhodtome  Vaccmyrt  Vaccviti  Pinusylv 
0.8254657 0.1953245 0.1824153 0.2406730 0.2110550 0.0060096 </pre>

</article></slide><slide class=''><hgroup><h2>Diagnostics for constrained ordinations </h2><h3> inertia decomposition</h3></hgroup><article  id="diagnostics-for-constrained-ordinations-inertia-decomposition" class="smaller ">

<p><code>inertcomp()</code> decomposes the variance in samples or species in partial, constrained, and unconstrained components</p>

<p>Same two types of measure available by argument <code>statistic</code></p>

<ul>
<li><code>statistic = &quot;explained</code> (default) gives the decomposition in terms of variance</li>
<li><code>statistic = &quot;distance&quot;</code> gives decomposition in terms of the the residual distance</li>
<li>Can output as proportions of total via <code>proportion = TRUE</code></li>
</ul>

<pre class = 'prettyprint lang-r'>head(inertcomp(mods, proportional = TRUE))</pre>

<pre >               CCA        CA
Callvulg 0.8254657 0.1745343
Empenigr 0.1953245 0.8046755
Rhodtome 0.1824153 0.8175847
Vaccmyrt 0.2406730 0.7593270
Vaccviti 0.2110550 0.7889450
Pinusylv 0.0060096 0.9939904</pre>

</article></slide><slide class=''><hgroup><h2>Diagnostics for constrained ordinations </h2><h3> species-environment correlations</h3></hgroup><article  id="diagnostics-for-constrained-ordinations-species-environment-correlations" class="smaller ">

<p><code>spenvcor()</code> returns the species-environment correlation</p>

<p>The (weighted) correlation between the weighted average-based and the linear combination-based sets of site scores</p>

<p>A <em>poor</em> measure of goodness of fit. Sensitive to</p>

<ul>
<li>outliers (like all correlations)</li>
<li>overfitting (using too many constraints)</li>
</ul>

<p>Better models can have poorer species-environment correlations</p>

<pre class = 'prettyprint lang-r'>spenvcor(mods)</pre>

<pre >     CCA1      CCA2      CCA3 
0.8554808 0.8132873 0.8792797 </pre>

</article></slide><slide class=''><hgroup><h2>Diagnostics for constrained ordinations </h2><h3> interset correlations</h3></hgroup><article  id="diagnostics-for-constrained-ordinations-interset-correlations" class="smaller ">

<p><code>intersetcor()</code> returns the interset correlations; the (weighted) correlation between the weighted average-based site scores and each constraint variable</p>

<p>Another <em>poor</em> diagnostic</p>

<ul>
<li>correlation based</li>
<li>focuses on a single constraint&#8211;axis combination at a time</li>
</ul>

<p>Vector fitting (<code>envfit()</code>) or biplot scores (<code>scores(model, display = &quot;bp&quot;)</code>) are better alternatives</p>

<pre class = 'prettyprint lang-r'>intersetcor(mods)</pre>

<pre >         CCA1       CCA2      CCA3
Al  0.7356151 -0.1302334 0.4259623
P  -0.3589749 -0.6110772 0.4478933
K  -0.3768462 -0.1339192 0.7760441</pre>

</article></slide><slide class='segue dark nobackground level1'><hgroup class = 'auto-fadein'><h2>Restricted permutation tests</h2></hgroup><article  id="restricted-permutation-tests" class="smaller ">

</article></slide><slide class=''><hgroup><h2>Restricted permutation tests</h2></hgroup><article  id="restricted-permutation-tests-1" class="smaller ">

<p>What <em>is</em> shuffled and <em>how</em> is of <strong>paramount</strong> importance for the test to be valid</p>

<p>Complete randomisation (default in <strong>vegan</strong>) assumes a null hypothesis where all observations are <em>independent</em></p>

<p>Ecological / environmental data often aren&#39;t independent</p>

<ul>
<li>Temporal or spatial correlation</li>
<li>Clustering, repeated measures</li>
<li>Nested sampling designs (Split-plots designs)</li>
<li>Blocks</li>
<li>&#8230;</li>
</ul>

<p>Permutation <em>must</em> give null distribution of the test statistic whilst preserving the <em>dependence</em> between observations</p>

<p>Trick is to shuffle the data whilst preserving that dependence</p>

</article></slide><slide class=''><hgroup><h2>Restricted permutations</h2></hgroup><article  id="restricted-permutations" class="smaller ">

<p>Canoco has had restricted permutations for a <em>long</em> time. <strong>vegan</strong> has only recently caught up &amp; we&#39;re not there yet</p>

<p><strong>vegan</strong> still only knows how to completely randomise data or completely randomise within blocks (called <code>strata</code> in <strong>vegan</strong>)</p>

<p>The newish package <strong>permute</strong> grew out of initial code in the <strong>vegan</strong> repository to generate the sorts of restricted permutations available in Canoco</p>

<p>We still haven&#39;t fully integrated <strong>permute</strong> into <strong>vegan</strong>&#8230;</p>

<p>&#8230;but you can pass <strong>vegan</strong> functions a matrix of permutations to use instead of having it generate its own</p>

<p><strong>vegan</strong> depends on <strong>permute</strong> so you should have it already installed &amp; loaded when using <strong>vegan</strong></p>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong></h2></hgroup><article  id="restricted-permutations-with-permute" class="smaller ">

<p><strong>permute</strong> follows Canoco closely &#8212; at the chiding of Cajo ter Braak when it didn&#39;t do what he wanted !</p>

<p>Samples can be thought of as belonging to three levels of a hierarchy</p>

<ul>
<li>the <em>sample</em> level; how are individual samples permuted</li>
<li>the <em>plot</em> level; how are samples grouped at an intermediate level</li>
<li>the <em>block</em> level; how are samples grouped at the outermost level</li>
</ul>

<p>Blocks define groups of plots, each of which can contain groups of samples</p>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong></h2></hgroup><article  id="restricted-permutations-with-permute-1" class="smaller ">

<p>Blocks are <em>never</em> permuted; if defined, only plots or samples <em>within</em> the blocks get shuffled &amp; samples never swapped between blocks</p>

<p>Plots or samples within plots, or both can be permuted following one of four simple permutation types</p>

<ol>
<li>Free permutation (randomisation)</li>
<li>Time series or linear transect, equal spacing</li>
<li>Spatial grid designs, equal regular spacing</li>
<li>Permutation of plots (groups of samples)</li>
<li>Fixed (no permutation)</li>
</ol>

<p>Multiple plots per block, multiple samples per plot; plots could be arranged in a spatial grid and samples within each of the plots form a time series</p>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> blocks</h3></hgroup><article  id="restricted-permutations-with-permute-blocks" class="smaller ">

<p>Blocks are a random factor that does not interact with factors that vary within blocks</p>

<p>Blocks form groups of samples that are never permuted between blocks, only within blocks</p>

<p>Using blocks you can achieve what the <code>strata</code> argument does now in <strong>vegan</strong>; needs to be a factor variable</p>

<p>The variation <em>between</em> blocks should be excluded from the test; <strong>permute</strong> doesn&#39;t do this for you!</p>

<p>Use <code>+ Condition(blocks)</code> in the model formula where <code>blocks</code> is a factor containing the block membership for each observation</p>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> time series &amp; linear transects</h3></hgroup><article  id="restricted-permutations-with-permute-time-series-linear-transects" class="smaller ">

<p>Can link <em>randomly</em> starting point of one series to any time point of another series if series are stationary under null hypothesis that the series are unrelated</p>

<p>Achieve this via cyclic shift permutations &#8212; wrap series into a circle by joining start and end points</p>

<p>Works OK if there are no trends or cyclic pattern &#8212; autocorrelation structure only broken at the end points <em>if</em> series are stationary</p>

<p>Can detrend to make series stationary but not if you want to test significance of a trend</p>

<pre class = 'prettyprint lang-r'>shuffle(10, control = how(within = Within(type = &quot;series&quot;)))</pre>

<pre > [1]  9 10  1  2  3  4  5  6  7  8</pre>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> spatial grids</h3></hgroup><article  id="restricted-permutations-with-permute-spatial-grids" class="smaller ">

<div class="columns-2">
<p>The trick of cyclic shifts can be extended to two dimensions for a regular spatial grid arrangement of points</p>

<p>Now shifts are <em>toroidal</em> as we join the end point in the <em>x</em> direction together and in the <em>y</em> direction together</p>

<pre class = 'prettyprint lang-r'>matrix(perm, ncol = 3)</pre>

<pre >     [,1] [,2] [,3]
[1,]    6    9    3
[2,]    4    7    1
[3,]    5    8    2</pre></div>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> whole-plots &amp; split-plots I</h3></hgroup><article  id="restricted-permutations-with-permute-whole-plots-split-plots-i" class="smaller ">

<p>Split-plot designs are hierarchical with two levels of units</p>

<ol>
<li><strong>whole-plots</strong> , which contain</li>
<li><strong>split-plots</strong> (the samples)</li>
</ol>

<p>Can permute one or both of these but whole-plots must be of equal size</p>

<p>Essentially allows more than one error stratum to be anlyzed</p>

<p>Test effect of constraints that vary <em>between</em> whole plots by permuting the whole-plots whilst retaining order of split-splots (samples) within the whole-plots</p>

<p>Test effect of constraints that vary <em>within</em> whole-plots by permuting the split-plots within whole-plots without permuting the whole-plots</p>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> whole-plots &amp; split-plots II</h3></hgroup><article  id="restricted-permutations-with-permute-whole-plots-split-plots-ii" class="smaller ">

<p>Whole-plots or split-plots can be time series, linear transects or rectangular grids in which case the appropriate restricted permutation is used</p>

<p>If the split-plots are parallel time series &amp; <code>time</code> is an autocorrelated error component affecting all series then the same cyclic shift can be applied to each time series (within each whole-plot) (<code>constant = TRUE</code>)</p>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> mirroring</h3></hgroup><article  id="restricted-permutations-with-permute-mirroring" class="smaller ">

<p>(Without wanting to get <em>too</em> technical) Mirroring in restricted permutations allows for isotropy in dependences by reflecting the ordering of samples in time or spatial dimensions</p>

<p>For a linear transect, technically the autocorrelation at lag <em>h</em> is equal to that at lag -<em>h</em> (also in a trend-free time series)</p>

<p>Hence the series <code>(1, 2, 3, 4)</code> and <code>(4, 3, 2, 1)</code> are equivalent fom this point of view &amp; we can draw permutations from either version</p>

<p>Similar argument can be made for spatial grids</p>

<p>Using <code>mirror = TRUE</code> then can double (time series, linear transects) or quadruple (spatial grids) the size of the set of permutations</p>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> the set of permutations</h3></hgroup><article  id="restricted-permutations-with-permute-the-set-of-permutations" class="smaller ">

<p>Using restricted permutations can severely reduce the size of the set of allowed permutations</p>

<p>As the minimum <em>p</em> value obtaininable is \(1 / np\) where \(np\) is number of allowed permutations (including the observed) this can impact the ability to detect signal/pattern</p>

<p>If we don&#39;t want mirroring</p>

<ul>
<li>in a time series of 20 samples the minimum <em>p</em> is 1/20 (0.05)</li>
<li>in a time series of 100 samples the minimum <em>p</em> is 1/100 (0.01)</li>
<li>in a data set with 10 time series each of 20 observations (200 total), if we assume an autocorrelated error component over all series (<code>constant = TRUE</code>) then there are only 20 permutations of the data and minimum <em>p</em> is 0.05</li>
</ul>

<p>When the set of permutations is small it is better to switch to an exact test &amp; evaluate all permutations in the set rather than randomly sample from the set</p>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> designing permutation schemes</h3></hgroup><article  id="restricted-permutations-with-permute-designing-permutation-schemes" class="smaller ">

<p>In <strong>permute</strong>, we set up a permutation scheme with <code>how()</code></p>

<p>We sample from the permutation scheme with</p>

<ul>
<li><code>shuffle()</code>, which gives a single draw from scheme, or</li>
<li><code>shuffleSet()</code>, which returns a set of <code>n</code> draws from the scheme</li>
</ul>

<p><code>allPerms()</code> can generated the entire set of permutations &#8212; <strong>note</strong> this was designed for small sets of permutations &amp; is slow if you request it for a scheme with many thousands of permutations!</p>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> designing permutation schemes</h3></hgroup><article  id="restricted-permutations-with-permute-designing-permutation-schemes-1" class="smaller ">

<p><code>how()</code> has three main arguments</p>

<ol>
<li><code>within</code> &#8212; takes input from helper <code>Within()</code></li>
<li><code>plots</code> &#8212; takes input from helper <code>Plots()</code></li>
<li><code>blocks</code> &#8212; takes a factor variable as input</li>
</ol>

<pre class = 'prettyprint lang-r'>plt &lt;- gl(3, 10)
h &lt;- how(within = Within(type = &quot;series&quot;), plots = Plots(strata = plt))</pre>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> designing permutation schemes</h3></hgroup><article  id="restricted-permutations-with-permute-designing-permutation-schemes-2" class="smaller ">

<p>Helper functions make it easy to change one or a few aspects of permutation scheme, rest left at defaults</p>

<pre class = 'prettyprint lang-r'>args(Within)</pre>

<pre >function (type = c(&quot;free&quot;, &quot;series&quot;, &quot;grid&quot;, &quot;none&quot;), constant = FALSE, 
    mirror = FALSE, ncol = NULL, nrow = NULL) 
NULL</pre>

<pre class = 'prettyprint lang-r'>args(Plots)</pre>

<pre >function (strata = NULL, type = c(&quot;none&quot;, &quot;free&quot;, &quot;series&quot;, &quot;grid&quot;), 
    mirror = FALSE, ncol = NULL, nrow = NULL) 
NULL</pre>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> designing permutation schemes</h3></hgroup><article  id="restricted-permutations-with-permute-designing-permutation-schemes-3" class="smaller ">

<p><code>how()</code> has additional arguments, many of which control the heuristics that kick in to stop you shooting yourself in the foot and demanding 9999 permutations when there are only 10</p>

<ul>
<li><code>complete</code> should we enumerate the entire set of permutations?</li>
<li><code>minperm</code> lower bound on the size of the set of permutations at &amp; below which we turn on complete enumeration</li>
</ul>

<pre class = 'prettyprint lang-r'>args(how)</pre>

<pre >function (within = Within(), plots = Plots(), blocks = NULL, 
    nperm = 199, complete = FALSE, maxperm = 9999, minperm = 99, 
    all.perms = NULL, make = TRUE, observed = FALSE) 
NULL</pre>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> time series example I</h3></hgroup><article  id="restricted-permutations-with-permute-time-series-example-i" class="smaller ">

<p>Time series within 3 plots, 10 observation each</p>

<pre class = 'prettyprint lang-r'>plt &lt;- gl(3, 10)
h &lt;- how(within = Within(type = &quot;series&quot;), plots = Plots(strata = plt))
set.seed(4)
p &lt;- shuffle(30, control = h)
do.call(&quot;rbind&quot;, split(p, plt)) ## look at perms in context</pre>

<pre >  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
1    7    8    9   10    1    2    3    4    5     6
2   12   13   14   15   16   17   18   19   20    11
3   24   25   26   27   28   29   30   21   22    23</pre>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> time series example II</h3></hgroup><article  id="restricted-permutations-with-permute-time-series-example-ii" class="smaller ">

<p>Time series within 3 plots, 10 observation each, same permutation within each</p>

<pre class = 'prettyprint lang-r'>plt &lt;- gl(3, 10)
h &lt;- how(within = Within(type = &quot;series&quot;, constant = TRUE), plots = Plots(strata = plt))
set.seed(4)
p &lt;- shuffle(30, control = h)
do.call(&quot;rbind&quot;, split(p, plt)) ## look at perms in context</pre>

<pre >  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
1    7    8    9   10    1    2    3    4    5     6
2   17   18   19   20   11   12   13   14   15    16
3   27   28   29   30   21   22   23   24   25    26</pre>

</article></slide><slide class=''><hgroup><h2>Restricted permutations with <strong>permute</strong> </h2><h3> worked example with <strong>vegan</strong></h3></hgroup><article  id="restricted-permutations-with-permute-worked-example-with-vegan" class="smaller ">

<p>Here by dragons</p>

<pre class = 'prettyprint lang-r'>## Analyse the Ohraz data Case study 5 of Leps &amp; Smilauer

## load vegan
library(&quot;vegan&quot;)

## load the data
spp &lt;- read.csv(&quot;data/ohraz-spp.csv&quot;, header = TRUE, row.names = 1)
env &lt;- read.csv(&quot;data/ohraz-env.csv&quot;, header = TRUE, row.names = 1)
molinia &lt;- spp[, 1]
spp &lt;- spp[, -1]

## Year as numeric
env &lt;- transform(env, year = as.numeric(as.character(year)))</pre>

<pre class = 'prettyprint lang-r'>## hypothesis 1
c1 &lt;- rda(spp ~ year + year:mowing + year:fertilizer +
          year:removal + Condition(plotid), data = env)

h &lt;- how(within = Within(type = &quot;none&quot;),
         plots = Plots(strata = env$plotid, type = &quot;free&quot;))
set.seed(42)
perm &lt;- shuffleSet(nrow(env), nset = 499, control = h)

anova(c1, permutations = h, model = &quot;reduced&quot;)</pre>

<pre >Permutation test for rda under reduced model
Plots: env$plotid, plot permutation: free
Permutation: none
Number of permutations: 199

Model: rda(formula = spp ~ year + year:mowing + year:fertilizer + year:removal + Condition(plotid), data = env)
         Df Variance      F Pr(&gt;F)   
Model     4   158.85 6.4247  0.005 **
Residual 90   556.30                 
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

<pre class = 'prettyprint lang-r'>anova(c1, permutations = h, model = &quot;reduced&quot;, by = &quot;axis&quot;)</pre>

<pre >Permutation test for rda under reduced model
Marginal tests for axes
Plots: env$plotid, plot permutation: free
Permutation: none
Number of permutations: 199

Model: rda(formula = spp ~ year + year:mowing + year:fertilizer + year:removal + Condition(plotid), data = env)
         Df Variance       F Pr(&gt;F)   
RDA1      1    89.12 14.4173  0.005 **
RDA2      1    34.28  5.5458  0.005 **
RDA3      1    26.52  4.2900  0.010 **
RDA4      1     8.94  1.4458  0.600   
Residual 90   556.30                  
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

<pre class = 'prettyprint lang-r'>## hypothesis 2
c2 &lt;- rda(spp ~ year:mowing + year:fertilizer + year:removal +
          Condition(year + plotid), data = env)
anova(c2, permutations = h, model = &quot;reduced&quot;)</pre>

<pre >Permutation test for rda under reduced model
Plots: env$plotid, plot permutation: free
Permutation: none
Number of permutations: 199

Model: rda(formula = spp ~ year:mowing + year:fertilizer + year:removal + Condition(year + plotid), data = env)
         Df Variance      F Pr(&gt;F)   
Model     3    99.24 5.3517  0.005 **
Residual 90   556.30                 
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

<pre class = 'prettyprint lang-r'>anova(c2, permutations = h, model = &quot;reduced&quot;, by = &quot;axis&quot;)</pre>

<pre >Permutation test for rda under reduced model
Marginal tests for axes
Plots: env$plotid, plot permutation: free
Permutation: none
Number of permutations: 199

Model: rda(formula = spp ~ year:mowing + year:fertilizer + year:removal + Condition(year + plotid), data = env)
         Df Variance      F Pr(&gt;F)   
RDA1      1    54.14 8.7595  0.005 **
RDA2      1    34.28 5.5458  0.005 **
RDA3      1    10.82 1.7499  0.500   
Residual 90   556.30                 
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</pre>

</article></slide><slide class=''><hgroup><h2>References</h2></hgroup><article  id="references" class="smaller unnumbered">

<div id="refs" class="references">
<div id="ref-Blanchet2008">
<p>Blanchet, F Guillaume, Pierre Legendre, and Daniel Borcard. 2008. “Forward Selection of Explanatory Variables.” <em>Ecology</em> 89 (9). Eco Soc America: 2623–32.</p></div></div></article></slide>


  <slide class="backdrop"></slide>

</slides>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

<!-- map slide visiblity events into shiny -->
<script>
  (function() {
    if (window.jQuery) {
       window.jQuery(document).on('slideleave', function(e) {
         window.jQuery(e.target).trigger('hidden');
      });
       window.jQuery(document).on('slideenter', function(e) {
         window.jQuery(e.target).trigger('shown');
      });
    }
  })();
</script>

</body>
</html>
